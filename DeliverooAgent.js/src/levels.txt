
SINGLE AGENT: 

25_c1_1 COOL
25_c1_2 COOL
25_c1_3 KINDA COOL : its our logic, it is how it is (explore) 
25_c1_4 KINDA COOL : its our logic, it is how it is (explore)
25_c1_5 COOL 
25_c1_6 COOL
25_c1_7 KINDA COOL : its our logic, it is how it is (explore)
25_c1_8 BREAK with bunch of AGENTS FIXED, 
25_c1_9 COOL



MULTI AGENTS: 

25_c2_1 KINDA COOL : its our logic, it is how it is (explore)
25_c2_2 KINDA COOL : its our logic, it is how it is (explore)
25_c2_3 COOL
25_c2_4 KINDA COOL its our logic, it is how it is (getScore)
25_c2_5 KINDA COOL : its our logic, it is how it is (explore)
25_c2_6 KINDA COOL its our logic, it is how it is (getScore)
25_c2_7 KINDA COOL its our logic, it is how it is (explore)

25_c2_hallway COOL : small detail could be better



PDDL + SINGLE AGENT: 

25_c1_1 COOL
25_c1_2 KINDA COOL its our logic, it is how it is (explore)
25_c1_3 KINDA COOL : its our logic, it is how it is (explore) 
25_c1_4 KINDA COOL : its our logic, it is how it is (explore)
25_c1_5 COOL 
25_c1_6 COOL
25_c1_7 didn't check
25_c1_8 didn't check
25_c1_9 didn't check 






CLEANING CODE SUGGESTIONS : 


SINGLE AGENT: 
1-      case 'go_deliver':
            // Check if we're still carrying parcels
            if (carriedParcels.size == 0)
                return false;
                check the Path for StillValid 

2-  // Find closest delivery point when agent is at a stationary position
    // if (global.graph && Number.isInteger(me.x) && Number.isInteger(me.y)) {
    //     utils.findClosestDelivery(me.x, me.y);
    // }
    in OnYou


MUTLI AGENTS:

1-      case 'go_deliver':
            // Check if we're still carrying parcels
            if (carriedParcels.size == 0)
                return false;
                check the Path for StillValid 

2- const UPDATE_THRESHOLD = 100; // ms - minimum time difference for updates
 3-    const data = {
        sendingFreeParcels: Object.fromEntries(freeParcels),
        sendingOtherAgents: Object.fromEntries(otherAgentsToSend),
        sendingCarriedParcels: Object.fromEntries(carriedParcels)
    };
    // Send the data to the other agent using the Deliveroo API
    client.emitSay(OTHER_AGENT_ID, data);
}, 100);
100 should be changed to maybe 50 which is MOVE_DURATION

4-  // Find closest delivery point when agent is at a stationary position
    // if (global.graph && Number.isInteger(me.x) && Number.isInteger(me.y)) {
    //     utils.findClosestDelivery(me.x, me.y);
    // }
    in OnYou

PLANNING AGENTS: 
1-      case 'go_deliver':
            // Check if we're still carrying parcels
            if (carriedParcels.size == 0)
                return false;
                check the Path for StillValid 

2-  // Find closest delivery point when agent is at a stationary position
    // if (global.graph && Number.isInteger(me.x) && Number.isInteger(me.y)) {
    //     utils.findClosestDelivery(me.x, me.y);
    // }
    in OnYou






    in all agents: 

   1- generate options is wrong : ( but then getscore should change as well )


    function generateOptions () {
    const carriedTotal = utils.carriedValue();

    let best_delivery_option = null;
    let best_pickup_option = null;
    let best_pickup_distance = Number.MAX_VALUE;

    // Check delivery option if carrying valuable parcels
    if (carriedTotal != 0) {
        const bestDelivery = utils.findClosestDelivery(me.x, me.y);
        if (bestDelivery && bestDelivery.deliveryPoint) {
            best_delivery_option = ['go_deliver', bestDelivery.deliveryPoint.x, bestDelivery.deliveryPoint.y, bestDelivery.path];
            if (best_delivery_option && bestDelivery.path && bestDelivery.path.length > 0) {
                myAgent.push(best_delivery_option);
            }
        }
    }

    // Always consider pickup options too, and pick nearest
    for (const parcel of freeParcels.values()) {
        if (
            Number.isInteger(me.x) && Number.isInteger(me.y) &&
            Number.isInteger(parcel.x) && Number.isInteger(parcel.y)
        ) {
            const pickupPath = utils.getShortestPath(me.x, me.y, parcel.x, parcel.y);
            if (pickupPath && pickupPath.cost !== null && pickupPath.cost < best_pickup_distance) {
                best_pickup_distance = pickupPath.cost;
                best_pickup_option = ['go_pick_up', parcel.x, parcel.y, parcel.id, pickupPath.path];
            }
        }
    }
    
    // Push the best option found or idle if no good options
    if ( best_pickup_option !== null && best_pickup_distance !== null ) {
        myAgent.push(best_pickup_option);
    }
    else if ( best_delivery_option === null ) {
        myAgent.push(['idle']);
    }
}


2- in INTENTION REVISION we should remove the intentions with score less than -1 (less than idle)

3- here we dont check for idle intention

if(!Number.isInteger(me.x) || !Number.isInteger(me.y)) return;

        // Check if intention is already being executed (first 3 elements match)
        const last = this.intention_queue[this.intention_queue.length - 1];
        if ( last && last.predicate.slice(0, 3).join(' ') == predicate.slice(0, 3).join(' ') ) {
            return; // intention is already being achieved
        }
        
        // Check for duplicate intentions with same first 4 elements
        if (this.intention_queue.some(i =>
            i.predicate.slice(0, 4).join(' ') === predicate.slice(0, 4).join(' ')
        )) {
            

4- best_delivery_option output should be fixed to be corrected